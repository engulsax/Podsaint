/* src/MultiCarousel.html generated by Svelte v3.0.0 */
import {
	SvelteComponent,
	add_binding_callback,
	append,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	safe_not_equal,
	space
} from "svelte/internal";
import { onMount } from "svelte";

// (3:2) {#if controls.indexOf('previous') !== -1}
function create_if_block_3(ctx) {
	var div, dispose;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<svg width="28" height="28" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><defs><filter id="shadow" x="0" y="0" width="200%" height="200%"><feOffset result="offOut" in="SourceAlpha" dx="0" dy="0"></feOffset><feGaussianBlur result="blurOut" in="offOut" stdDeviation="10"></feGaussianBlur><feBlend in="SourceGraphic" in2="blurOut" mode="normal"></feBlend></filter></defs><path filter="url(#shadow)" d="M1427 301l-531 531 531 531q19 19 19 45t-19 45l-166 166q-19 19-45 19t-45-19l-742-742q-19-19-19-45t19-45l742-742q19-19 45-19t45 19l166 166q19 19 19 45t-19 45z"></path></svg>`;
			div.className = "previous svelte-v96mw1";
			dispose = listen(div, "click", ctx.previous);
		},

		m(target, anchor) {
			insert(target, div, anchor);
		},

		p: noop,

		d(detaching) {
			if (detaching) {
				detach(div);
			}

			dispose();
		}
	};
}

// (17:2) {#if controls.indexOf('next') !== -1}
function create_if_block_2(ctx) {
	var div, dispose;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<svg width="28" height="28" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><defs><filter id="shadow" x="0" y="0" width="200%" height="200%"><feOffset result="offOut" in="SourceAlpha" dx="0" dy="0"></feOffset><feGaussianBlur result="blurOut" in="offOut" stdDeviation="10"></feGaussianBlur><feBlend in="SourceGraphic" in2="blurOut" mode="normal"></feBlend></filter></defs><path filter="url(#shadow)" d="M1363 877l-742 742q-19 19-45 19t-45-19l-166-166q-19-19-19-45t19-45l531-531-531-531q-19-19-19-45t19-45l166-166q19-19 45-19t45 19l742 742q19 19 19 45t-19 45z"></path></svg>`;
			div.className = "next svelte-v96mw1";
			dispose = listen(div, "click", ctx.next);
		},

		m(target, anchor) {
			insert(target, div, anchor);
		},

		p: noop,

		d(detaching) {
			if (detaching) {
				detach(div);
			}

			dispose();
		}
	};
}

// (31:2) {#if timer && controls.indexOf('pause') !== -1}
function create_if_block_1(ctx) {
	var div, dispose;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<svg width="28" height="28" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><defs><filter id="shadow" x="0" y="0" width="200%" height="200%"><feOffset result="offOut" in="SourceAlpha" dx="0" dy="0"></feOffset><feGaussianBlur result="blurOut" in="offOut" stdDeviation="10"></feGaussianBlur><feBlend in="SourceGraphic" in2="blurOut" mode="normal"></feBlend></filter></defs><path filter="url(#shadow)" transform="translate(179.2 179.2) scale(0.8)" d="M1664 192v1408q0 26-19 45t-45 19h-512q-26 0-45-19t-19-45v-1408q0-26 19-45t45-19h512q26 0 45 19t19 45zm-896 0v1408q0 26-19 45t-45 19h-512q-26 0-45-19t-19-45v-1408q0-26 19-45t45-19h512q26 0 45 19t19 45z"></path></svg>`;
			div.className = "pause svelte-v96mw1";
			dispose = listen(div, "click", ctx.pause);
		},

		m(target, anchor) {
			insert(target, div, anchor);
		},

		p: noop,

		d(detaching) {
			if (detaching) {
				detach(div);
			}

			dispose();
		}
	};
}

// (45:2) {#if !timer && controls.indexOf('start') !== -1}
function create_if_block(ctx) {
	var div, dispose;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<svg width="28" height="28" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><defs><filter id="shadow" x="0" y="0" width="200%" height="200%"><feOffset result="offOut" in="SourceAlpha" dx="0" dy="0"></feOffset><feGaussianBlur result="blurOut" in="offOut" stdDeviation="10"></feGaussianBlur><feBlend in="SourceGraphic" in2="blurOut" mode="normal"></feBlend></filter></defs><path filter="url(#shadow)" transform="translate(179.2 179.2) scale(0.8)" d="M1576 927l-1328 738q-23 13-39.5 3t-16.5-36v-1472q0-26 16.5-36t39.5 3l1328 738q23 13 23 31t-23 31z"></path></svg>`;
			div.className = "start svelte-v96mw1";
			dispose = listen(div, "click", ctx.start);
		},

		m(target, anchor) {
			insert(target, div, anchor);
		},

		p: noop,

		d(detaching) {
			if (detaching) {
				detach(div);
			}

			dispose();
		}
	};
}

function create_fragment(ctx) {
	var div1, t0, t1, t2, t3, div0;

	var if_block0 = (ctx.controls.indexOf('previous') !== -1) && create_if_block_3(ctx);

	var if_block1 = (ctx.controls.indexOf('next') !== -1) && create_if_block_2(ctx);

	var if_block2 = (ctx.timer && ctx.controls.indexOf('pause') !== -1) && create_if_block_1(ctx);

	var if_block3 = (!ctx.timer && ctx.controls.indexOf('start') !== -1) && create_if_block(ctx);

	return {
		c() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			div0 = element("div");
			div0.className = "items svelte-v96mw1";
			div1.className = "multicarousel svelte-v96mw1";
		},

		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t0);
			if (if_block1) if_block1.m(div1, null);
			append(div1, t1);
			if (if_block2) if_block2.m(div1, null);
			append(div1, t2);
			if (if_block3) if_block3.m(div1, null);
			append(div1, t3);
			append(div1, div0);
			add_binding_callback(() => ctx.div0_binding(div0, null));
		},

		p(changed, ctx) {
			if (ctx.controls.indexOf('previous') !== -1) {
				if (if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (ctx.controls.indexOf('next') !== -1) {
				if (if_block1) {
					if_block1.p(changed, ctx);
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					if_block1.m(div1, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (ctx.timer && ctx.controls.indexOf('pause') !== -1) {
				if (if_block2) {
					if_block2.p(changed, ctx);
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					if_block2.m(div1, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (!ctx.timer && ctx.controls.indexOf('start') !== -1) {
				if (if_block3) {
					if_block3.p(changed, ctx);
				} else {
					if_block3 = create_if_block(ctx);
					if_block3.c();
					if_block3.m(div1, t3);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (changed.items) {
				ctx.div0_binding(null, div0);
				;
				ctx.div0_binding(div0, null);
			}
		},

		i: noop,
		o: noop,

		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			ctx.div0_binding(null, div0);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { delay = 1500, transition = 600, items = [], count = 5, controls = [
    'previous',
    'next',
    'pause',
    'start'
  ] } = $$props;

  let itemsElement;
  let transitioning = false;
  let timer = null;

  onMount(() => {
    for (let i = 0; i < items.length; i++) {
      itemsElement.appendChild(items[i]);
      items[i].style.width = width; $$invalidate('items', items);
    }
    for (let i = 0; i < count; i++) {
      items[i].classList.add('active');
    }
    itemsElement.style.left = '0'; $$invalidate('itemsElement', itemsElement);
    itemsElement.style.transition = cssTransition; $$invalidate('itemsElement', itemsElement);
    start();
  });

  const next = () => {
    if (transitioning) {
      return;
    }

    $$invalidate('transitioning', transitioning = true);
    const children = itemsElement.children;
    let foundActive = false;
    let previousElem;
    // Find the first one marked active, then the first one not active.
    for (let i = 0; i < children.length; i++) {
      if (!foundActive && children[i].classList.contains('active')) {
        previousElem = children[i];
        foundActive = true;
        continue;
      }
      if (foundActive && !children[i].classList.contains('active')) {
        children[i].classList.add('active');
        break;
      }
    }
    itemsElement.style.transition = cssTransition; $$invalidate('itemsElement', itemsElement);
    itemsElement.style.left = '-'+width; $$invalidate('itemsElement', itemsElement);

    // Wait the transition time, then move the previous element to the end.
    setTimeout(() => {
      previousElem.classList.remove('active');
      itemsElement.style.transition = ''; $$invalidate('itemsElement', itemsElement);
      itemsElement.style.left = '0'; $$invalidate('itemsElement', itemsElement);
      itemsElement.appendChild(previousElem);
      $$invalidate('transitioning', transitioning = false);
    }, transition);

    // Restart the timer.
    if (timer) {
      start();
    }
  };

  const previous = () => {
    if (transitioning) {
      return;
    }

    $$invalidate('transitioning', transitioning = true);
    const children = itemsElement.children;
    let previousElem = children[children.length - 1];
    previousElem.classList.add('active');
    itemsElement.insertBefore(previousElem, children[0]);
    requestAnimationFrame(() => {
      itemsElement.style.transition = ''; $$invalidate('itemsElement', itemsElement);
      itemsElement.style.left = '-'+width; $$invalidate('itemsElement', itemsElement);
      setTimeout(() => {
        itemsElement.style.transition = cssTransition; $$invalidate('itemsElement', itemsElement);
        itemsElement.style.left = '0'; $$invalidate('itemsElement', itemsElement);
      }, 0);
    });

    // Wait the transition time.
    setTimeout(() => {
      // Find the last one marked active.
      for (let i = children.length - 1; i >= 0; i--) {
        if (children[i].classList.contains('active')) {
          children[i].classList.remove('active');
          break;
        }
      }
      itemsElement.style.transition = ''; $$invalidate('itemsElement', itemsElement);
      $$invalidate('transitioning', transitioning = false);
    }, transition);

    // Restart the timer.
    if (timer) {
      start();
    }
  };

  const pause = () => {
    clearInterval(timer);
    $$invalidate('timer', timer = null);
  };

  const start = () => {
    if (delay > 0) {
      if (timer) pause();
      $$invalidate('timer', timer = setInterval(next, delay));
    }
  };

	function div0_binding($$node, check) {
		itemsElement = $$node;
		$$invalidate('itemsElement', itemsElement);
	}

	$$self.$set = $$props => {
		if ('delay' in $$props) $$invalidate('delay', delay = $$props.delay);
		if ('transition' in $$props) $$invalidate('transition', transition = $$props.transition);
		if ('items' in $$props) $$invalidate('items', items = $$props.items);
		if ('count' in $$props) $$invalidate('count', count = $$props.count);
		if ('controls' in $$props) $$invalidate('controls', controls = $$props.controls);
	};

	let cssTransition, width;
	$$self.$$.update = ($$dirty = { transition: 1, count: 1 }) => {
		if ($$dirty.transition) { $$invalidate('cssTransition', cssTransition = `left ${transition / 1000}s`); }
		if ($$dirty.count) { $$invalidate('width', width = `${100 / count}%`); }
	};

	return {
		delay,
		transition,
		items,
		count,
		controls,
		itemsElement,
		timer,
		next,
		previous,
		pause,
		start,
		div0_binding
	};
}

class MultiCarousel extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, ["delay", "transition", "items", "count", "controls", "next", "previous", "pause", "start"]);
	}

	get next() {
		return this.$$.ctx.next;
	}

	get previous() {
		return this.$$.ctx.previous;
	}

	get pause() {
		return this.$$.ctx.pause;
	}

	get start() {
		return this.$$.ctx.start;
	}
}

export default MultiCarousel;